import fs from "fs";
import path from "path";
import { v4 as uuidv4 } from "uuid";
import { format } from "date-fns";

export class DebugLogger {
  constructor() {
    this.sessions = new Map();
    this.logsPath = path.join(process.cwd(), "logs", "debugging-sessions");
    this.ensureLogsDirectory();
  }

  ensureLogsDirectory() {
    try {
      fs.mkdirSync(this.logsPath, { recursive: true });
    } catch (error) {
      console.error("Failed to create logs directory:", error.message);
    }
  }

  startSession() {
    const sessionId = uuidv4();
    const session = {
      id: sessionId,
      startTime: new Date(),
      logs: [],
      status: "active",
      totalIssues: 0,
      resolvedIssues: 0
    };
    
    this.sessions.set(sessionId, session);
    console.log(`📋 Started debugging session: ${sessionId}`);
    
    return sessionId;
  }

  async logDebuggingSession(sessionId, logData) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      console.error(`❌ Session ${sessionId} not found`);
      return;
    }

    // Add unique ID to log entry
    logData.id = uuidv4();
    logData.entryNumber = session.logs.length + 1;
    
    session.logs.push(logData);
    session.totalIssues++;
    
    console.log(`📝 Logged debug entry ${logData.entryNumber} for session ${sessionId}`);
    
    // Write to file immediately for persistence
    await this.writeSessionLog(sessionId, session);
    
    // Also write individual log entry for quick access
    await this.writeIndividualLog(sessionId, logData);
  }

  async writeSessionLog(sessionId, session) {
    const timestamp = format(session.startTime, "yyyy-MM-dd-HH-mm-ss");
    const filename = `debug-session-${sessionId.substring(0, 8)}-${timestamp}.md`;
    const filepath = path.join(this.logsPath, filename);
    
    const markdown = this.generateMarkdownLog(session);
    
    try {
      await fs.promises.writeFile(filepath, markdown, "utf8");
      console.log(`💾 Session log updated: ${filename}`);
    } catch (error) {
      console.error(`❌ Failed to write session log: ${error.message}`);
    }
  }

  async writeIndividualLog(sessionId, logData) {
    const timestamp = format(new Date(logData.timestamp), "yyyy-MM-dd-HH-mm-ss");
    const filename = `debug-entry-${logData.entryNumber}-${sessionId.substring(0, 8)}-${timestamp}.md`;
    const filepath = path.join(this.logsPath, "individual-entries", filename);
    
    // Ensure individual entries directory exists
    const individualDir = path.join(this.logsPath, "individual-entries");
    fs.mkdirSync(individualDir, { recursive: true });
    
    const markdown = this.generateIndividualLogMarkdown(logData);
    
    try {
      await fs.promises.writeFile(filepath, markdown, "utf8");
    } catch (error) {
      console.error(`❌ Failed to write individual log: ${error.message}`);
    }
  }

  generateMarkdownLog(session) {
    const duration = session.endTime 
      ? Math.round((session.endTime - session.startTime) / 1000)
      : Math.round((new Date() - session.startTime) / 1000);

    const header = `# Claude Code Debugging Session

## Session Overview
- **Session ID:** \`${session.id}\`
- **Start Time:** ${session.startTime.toISOString()}
- **Status:** ${session.status}
- **Duration:** ${duration} seconds
- **Total Issues:** ${session.totalIssues}
- **Resolved Issues:** ${session.resolvedIssues}
- **Success Rate:** ${session.totalIssues > 0 ? Math.round((session.resolvedIssues / session.totalIssues) * 100) : 0}%

## Session Statistics
- **Log Entries:** ${session.logs.length}
- **Error Types:** ${this.getErrorTypes(session.logs).join(", ")}
- **Most Common Issue:** ${this.getMostCommonIssue(session.logs)}

---

`;

    const logs = session.logs.map((log, index) => {
      return this.generateLogEntry(log, index + 1);
    }).join("\n---\n\n");

    const footer = `
## Session Summary

### Key Patterns Identified
${this.identifyPatterns(session.logs)}

### Recommendations for Future Sessions
${this.generateRecommendations(session.logs)}

### Files Generated
- Session log: \`debug-session-${session.id.substring(0, 8)}-${format(session.startTime, "yyyy-MM-dd-HH-mm-ss")}.md\`
- Individual entries: \`individual-entries/debug-entry-*-${session.id.substring(0, 8)}-*.md\`

---
*Generated by Claude Code Debug Middleware v1.0.0*
`;

    return header + logs + footer;
  }

  generateIndividualLogMarkdown(logData) {
    return `# Debug Entry ${logData.entryNumber}

**Entry ID:** \`${logData.id}\`
**Timestamp:** ${logData.timestamp}
**Session ID:** \`${logData.sessionId || "unknown"}\`

## Issue Details
${this.formatIssueDetails(logData)}

## Context Information
${this.formatContextDetails(logData.context)}

## Error Information
\`\`\`json
${JSON.stringify(logData.error, null, 2)}
\`\`\`

## Debug Prompt Used
\`\`\`markdown
${logData.debugPrompt || "No debug prompt recorded"}
\`\`\`

## Expected Claude Response Format
The following debugging log should be generated by Claude Code:

### Debugging Log
**Date/Time:** ${logData.timestamp}
**Issue:** [To be filled by Claude]
**Context:** [To be filled by Claude]
**Diagnosis:** [To be filled by Claude]
**Attempts & Results:** [To be filled by Claude]
**Resolution:** [To be filled by Claude]
**Lessons Learned:** [To be filled by Claude]

---
*Individual debug entry - part of larger session*
`;
  }

  generateLogEntry(log, entryNumber) {
    return `## Debug Entry ${entryNumber}

**Entry ID:** \`${log.id}\`
**Timestamp:** ${log.timestamp}
**Issue Type:** ${this.classifyIssue(log)}

### Debugging Log Template
**Date/Time:** ${log.timestamp}
**Issue:** ${this.extractIssue(log)}
**Context:** ${this.formatContext(log.context)}
**Diagnosis:** ${this.extractDiagnosis(log)}
**Attempts & Results:** ${this.formatAttempts(log)}
**Resolution:** ${this.extractResolution(log)}
**Lessons Learned:** ${this.extractLessons(log)}

### Raw Data
<details>
<summary>Click to expand raw log data</summary>

\`\`\`json
${JSON.stringify(log, null, 2)}
\`\`\`
</details>`;
  }

  classifyIssue(log) {
    if (log.error?.type) {
      return log.error.type;
    }
    
    if (log.error?.error && typeof log.error.error === 'string') {
      if (log.error.error.includes('syntax')) return 'Syntax Error';
      if (log.error.error.includes('runtime')) return 'Runtime Error';
      if (log.error.error.includes('compilation')) return 'Compilation Error';
      if (log.error.error.includes('network')) return 'Network Error';
      if (log.error.error.includes('permission')) return 'Permission Error';
    }
    
    return 'Unknown Issue';
  }

  extractIssue(log) {
    if (log.error?.type) {
      return log.error.type;
    }
    
    if (log.error?.error) {
      // Extract first line of error message
      const errorLines = log.error.error.split('\n');
      return errorLines[0].substring(0, 100) + (errorLines[0].length > 100 ? "..." : "");
    }
    
    return "Issue details to be analyzed by Claude";
  }

  formatContext(context) {
    if (!context) return "No context available";
    
    const contextItems = [];
    
    if (context.userIntent) {
      contextItems.push(`**User Intent:** ${context.userIntent}`);
    }
    
    if (context.timestamp) {
      contextItems.push(`**Timestamp:** ${context.timestamp}`);
    }
    
    if (context.input) {
      contextItems.push(`**Input Type:** ${context.input.type || 'unknown'}`);
    }
    
    return contextItems.length > 0 ? contextItems.join('\n') : "Context to be analyzed by Claude";
  }

  formatContextDetails(context) {
    if (!context) return "No context available";
    
    return `
**User Intent:** ${context.userIntent || "Unknown"}
**Timestamp:** ${context.timestamp || "Unknown"}
**Input Details:**
\`\`\`json
${JSON.stringify(context.input, null, 2)}
\`\`\`
    `.trim();
  }

  formatIssueDetails(logData) {
    const issueType = this.classifyIssue(logData);
    const issueDescription = this.extractIssue(logData);
    
    return `
**Issue Type:** ${issueType}
**Description:** ${issueDescription}
**Severity:** ${this.assessSeverity(logData)}
**Category:** ${this.categorizeIssue(logData)}
    `.trim();
  }

  assessSeverity(logData) {
    // Simple heuristic for severity assessment
    if (logData.error?.error) {
      const errorText = logData.error.error.toLowerCase();
      if (errorText.includes('crash') || errorText.includes('fatal')) return 'High';
      if (errorText.includes('error') || errorText.includes('exception')) return 'Medium';
      if (errorText.includes('warning') || errorText.includes('deprecated')) return 'Low';
    }
    return 'Medium';
  }

  categorizeIssue(logData) {
    const issueType = this.classifyIssue(logData);
    
    const categories = {
      'Syntax Error': 'Code Quality',
      'Runtime Error': 'Execution',
      'Compilation Error': 'Build Process',
      'Network Error': 'Infrastructure',
      'Permission Error': 'Security/Access'
    };
    
    return categories[issueType] || 'General';
  }

  extractDiagnosis(log) {
    return "Root cause analysis to be provided by Claude Code";
  }

  formatAttempts(log) {
    return "Solution attempts to be documented by Claude Code";
  }

  extractResolution(log) {
    return log.resolved ? "Issue resolved successfully" : "Resolution pending - to be updated by Claude Code";
  }

  extractLessons(log) {
    return "Key insights and prevention strategies to be provided by Claude Code";
  }

  getErrorTypes(logs) {
    const types = new Set();
    logs.forEach(log => {
      types.add(this.classifyIssue(log));
    });
    return Array.from(types);
  }

  getMostCommonIssue(logs) {
    const issueCounts = {};
    logs.forEach(log => {
      const issue = this.classifyIssue(log);
      issueCounts[issue] = (issueCounts[issue] || 0) + 1;
    });
    
    const mostCommon = Object.entries(issueCounts)
      .sort(([,a], [,b]) => b - a)[0];
    
    return mostCommon ? `${mostCommon[0]} (${mostCommon[1]} occurrences)` : "No issues recorded";
  }

  identifyPatterns(logs) {
    const patterns = [];
    
    // Check for recurring error types
    const errorTypes = this.getErrorTypes(logs);
    if (errorTypes.length > 1) {
      patterns.push(`- Multiple error types encountered: ${errorTypes.join(", ")}`);
    }
    
    // Check for time-based patterns
    const timeGaps = this.analyzeTimeGaps(logs);
    if (timeGaps.length > 0) {
      patterns.push(`- Time gaps between issues: ${timeGaps.join(", ")} seconds`);
    }
    
    return patterns.length > 0 ? patterns.join('\n') : "- No significant patterns identified in this session";
  }

  analyzeTimeGaps(logs) {
    if (logs.length < 2) return [];
    
    const gaps = [];
    for (let i = 1; i < logs.length; i++) {
      const prev = new Date(logs[i-1].timestamp);
      const curr = new Date(logs[i].timestamp);
      const gap = Math.round((curr - prev) / 1000);
      gaps.push(gap);
    }
    
    return gaps;
  }

  generateRecommendations(logs) {
    const recommendations = [];
    
    // Based on error types
    const errorTypes = this.getErrorTypes(logs);
    if (errorTypes.includes('Syntax Error')) {
      recommendations.push("- Consider using a linter or code formatter to catch syntax errors early");
    }
    if (errorTypes.includes('Runtime Error')) {
      recommendations.push("- Implement more comprehensive error handling and validation");
    }
    if (errorTypes.includes('Network Error')) {
      recommendations.push("- Add retry logic and better network error handling");
    }
    
    // Based on frequency
    if (logs.length > 5) {
      recommendations.push("- High number of issues detected - consider breaking down complex tasks");
    }
    
    return recommendations.length > 0 
      ? recommendations.join('\n') 
      : "- Continue current debugging practices - session appears well-managed";
  }

  finalizeSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.status = "completed";
      session.endTime = new Date();
      
      // Calculate final statistics
      session.resolvedIssues = session.logs.filter(log => log.resolved).length;
      
      this.writeSessionLog(sessionId, session);
      console.log(`✅ Finalized debugging session: ${sessionId}`);
      console.log(`📊 Session stats: ${session.totalIssues} issues, ${session.resolvedIssues} resolved`);
      
      // Clean up from memory after a delay
      setTimeout(() => {
        this.sessions.delete(sessionId);
      }, 60000); // Keep in memory for 1 minute after completion
    }
  }

  // Utility method to get session statistics
  getSessionStats(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session) return null;
    
    return {
      id: session.id,
      status: session.status,
      startTime: session.startTime,
      endTime: session.endTime,
      duration: session.endTime 
        ? Math.round((session.endTime - session.startTime) / 1000)
        : Math.round((new Date() - session.startTime) / 1000),
      totalIssues: session.totalIssues,
      resolvedIssues: session.resolvedIssues,
      successRate: session.totalIssues > 0 
        ? Math.round((session.resolvedIssues / session.totalIssues) * 100) 
        : 0
    };
  }
}